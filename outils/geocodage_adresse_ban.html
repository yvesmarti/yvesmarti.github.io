<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Outil de Géocodage - Base Adresse Nationale - YM - 08-2025</title>
    
    <!-- Leaflet CSS pour la carte -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    
    <!-- Font Awesome pour les icônes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .upload-section {
            padding: 30px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-bottom: 1px solid #dee2e6;
        }

        .upload-area {
            border: 3px dashed #007bff;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: white;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #0056b3;
            background: #f8f9ff;
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #28a745;
            background: #f0fff4;
        }

        .upload-icon {
            font-size: 3em;
            color: #007bff;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #495057;
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.4);
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d, #5a6268);
        }

        .column-mapping {
            margin-top: 30px;
            padding: 30px;
            background: white;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .column-mapping h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .column-mapping p {
            color: #6c757d;
            margin-bottom: 25px;
        }

        .mapping-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .mapping-item {
            display: flex;
            flex-direction: column;
        }

        .mapping-item label {
            font-weight: bold;
            color: #495057;
            margin-bottom: 8px;
        }

        .column-select {
            padding: 10px 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
            background: white;
        }

        .column-select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.25);
        }

        .mapping-preview {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .mapping-preview h4 {
            color: #495057;
            margin-bottom: 10px;
        }

        .preview-address {
            font-size: 1.1em;
            color: #007bff;
            font-weight: bold;
            font-style: italic;
        }

        .mapping-actions {
            text-align: center;
        }

        .progress-container {
            margin: 20px 0;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
        }

        .main-content {
            display: flex;
            height: 70vh;
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .table-container {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #dee2e6;
        }

        .table-header {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        .search-box {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .search-box:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.25);
        }

        .table-wrapper {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .address-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        .address-table th {
            background: #2c3e50;
            color: white;
            padding: 12px 15px;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .address-table td {
            padding: 10px 15px;
            border-bottom: 1px solid #dee2e6;
            transition: background-color 0.3s ease;
        }

        .address-table tbody tr:hover {
            background: #f8f9ff;
            cursor: pointer;
        }

        .address-table tbody tr.selected {
            background: #e3f2fd;
            font-weight: bold;
        }

        .status-success {
            color: #28a745;
            font-weight: bold;
        }

        .status-error {
            color: #dc3545;
            font-weight: bold;
        }

        .stats {
            padding: 20px;
            background: #f8f9fa;
            display: flex;
            justify-content: space-around;
            text-align: center;
        }

        .stat-item {
            flex: 1;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
        }

        .stat-label {
            color: #6c757d;
            margin-top: 5px;
        }

        .export-section {
            padding: 20px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            text-align: center;
        }

        .export-section h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .export-section p {
            color: #6c757d;
            margin-bottom: 20px;
        }

        .export-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .export-info {
            color: #6c757d;
            font-size: 0.9em;
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            text-align: left;
            max-width: 600px;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
                height: auto;
            }
            
            .map-container, .table-container {
                min-height: 400px;
            }
            
            .table-container {
                border-left: none;
                border-top: 1px solid #dee2e6;
            }
        }

        // Affichage de l'interface de mapping des colonnes
        function showColumnMapping() {
            document.getElementById('columnMapping').style.display = 'block';
            populateColumnSelects();
        }

        // Remplissage des sélecteurs de colonnes
        function populateColumnSelects() {
            const selectors = ['numeroColumn', 'rueColumn', 'codePostalColumn', 'communeColumn'];
            
            selectors.forEach(selectorId => {
                const select = document.getElementById(selectorId);
                // Conserver la première option (-- Optionnel -- ou -- Sélectionner --)
                const firstOption = select.children[0].outerHTML;
                select.innerHTML = firstOption;
                
                csvHeaders.forEach(header => {
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    select.appendChild(option);
                });
            });

            // Essayer de détecter automatiquement certaines colonnes
            autoDetectColumns();
        }

        // Détection automatique des colonnes probables
        function autoDetectColumns() {
            const detectionRules = {
                numeroColumn: ['numero', 'num', 'n°', 'number'],
                rueColumn: ['rue', 'voie', 'street', 'adresse', 'address'],
                codePostalColumn: ['code', 'postal', 'cp', 'zip', 'postcode'],
                communeColumn: ['commune', 'ville', 'city', 'town', 'localite']
            };

            Object.keys(detectionRules).forEach(selectId => {
                const select = document.getElementById(selectId);
                const keywords = detectionRules[selectId];
                
                const matchedHeader = csvHeaders.find(header => 
                    keywords.some(keyword => 
                        header.toLowerCase().includes(keyword.toLowerCase())
                    )
                );

                if (matchedHeader) {
                    select.value = matchedHeader;
                }
            });

            updatePreview();
        }

        // Mise à jour de l'aperçu de l'adresse
        function updatePreview() {
            const numero = document.getElementById('numeroColumn').value;
            const rue = document.getElementById('rueColumn').value;
            const codePostal = document.getElementById('codePostalColumn').value;
            const commune = document.getElementById('communeColumn').value;

            if (!rue) {
                document.getElementById('previewAddress').textContent = 
                    'Veuillez au minimum sélectionner une colonne pour le nom de la rue';
                return;
            }

            // Construire un exemple d'adresse avec la première ligne de données
            const firstRow = csvData[0] || {};
            const parts = [];

            if (numero && firstRow[numero]) parts.push(firstRow[numero]);
            if (rue && firstRow[rue]) parts.push(firstRow[rue]);
            if (codePostal && firstRow[codePostal]) parts.push(firstRow[codePostal]);
            if (commune && firstRow[commune]) parts.push(firstRow[commune]);

            const exampleAddress = parts.join(' ').trim() || 'Exemple d\'adresse';
            document.getElementById('previewAddress').textContent = `Exemple: ${exampleAddress}`;
        }

        // Démarrage du géocodage avec mapping personnalisé
        function startGeocodingWithMapping() {
            const rue = document.getElementById('rueColumn').value;
            
            if (!rue) {
                alert('Veuillez sélectionner au minimum une colonne pour le nom de la rue.');
                return;
            }

            const numero = document.getElementById('numeroColumn').value;
            const codePostal = document.getElementById('codePostalColumn').value;
            const commune = document.getElementById('communeColumn').value;

            // Construire les adresses à partir des colonnes sélectionnées
            const addressData = csvData.map(row => {
                const parts = [];
                
                if (numero && row[numero]) parts.push(row[numero]);
                if (rue && row[rue]) parts.push(row[rue]);
                if (codePostal && row[codePostal]) parts.push(row[codePostal]);
                if (commune && row[commune]) parts.push(row[commune]);

                return {
                    adresse: parts.join(' ').trim(),
                    originalRow: row
                };
            }).filter(item => item.adresse); // Filtrer les lignes vides

            console.log('Adresses construites:', addressData);

            // Masquer le mapping et démarrer le géocodage
            document.getElementById('columnMapping').style.display = 'none';
            startGeocoding(addressData);
        }

        // Réinitialisation pour choisir un autre fichier
        function resetUpload() {
            document.getElementById('columnMapping').style.display = 'none';
            document.getElementById('fileInput').value = '';
            csvData = [];
            csvHeaders = [];
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .loading-spinner {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-map-marked-alt"></i> Outil de Géocodage</h1>
            <p>Base d'Adresse Nationale - Géocodage d'adresses françaises - YM - 08-2025</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <i class="fas fa-cloud-upload-alt upload-icon"></i>
                <div class="upload-text">Glissez votre fichier CSV ici ou cliquez pour sélectionner</div>
                <p>L'outil détectera automatiquement vos colonnes d'adresses</p>
                <input type="file" id="fileInput" class="file-input" accept=".csv">
                <button class="btn" onclick="document.getElementById('fileInput').click()">
                    <i class="fas fa-file-csv"></i> Choisir un fichier CSV
                </button>
            </div>

            <!-- Section de mapping des colonnes -->
            <div class="column-mapping" id="columnMapping" style="display: none;">
                <h3><i class="fas fa-columns"></i> Configuration des colonnes</h3>
                <p>Sélectionnez les colonnes correspondant à chaque élément de l'adresse :</p>
                
                <div class="mapping-grid">
                    <div class="mapping-item">
                        <label>Numéro de rue :</label>
                        <select id="numeroColumn" class="column-select">
                            <option value="">-- Optionnel --</option>
                        </select>
                    </div>
                    
                    <div class="mapping-item">
                        <label>Nom de la rue :</label>
                        <select id="rueColumn" class="column-select">
                            <option value="">-- Sélectionner --</option>
                        </select>
                    </div>
                    
                    <div class="mapping-item">
                        <label>Code postal :</label>
                        <select id="codePostalColumn" class="column-select">
                            <option value="">-- Optionnel --</option>
                        </select>
                    </div>
                    
                    <div class="mapping-item">
                        <label>Commune/Ville :</label>
                        <select id="communeColumn" class="column-select">
                            <option value="">-- Optionnel --</option>
                        </select>
                    </div>
                </div>

                <div class="mapping-preview">
                    <h4>Aperçu de l'adresse construite :</h4>
                    <div class="preview-address" id="previewAddress">Sélectionnez vos colonnes pour voir l'aperçu</div>
                </div>

                <div class="mapping-actions">
                    <button class="btn" id="startGeocodingBtn">
                        <i class="fas fa-play"></i> Commencer le géocodage
                    </button>
                    <button class="btn btn-secondary" id="resetBtn">
                        <i class="fas fa-undo"></i> Choisir un autre fichier
                    </button>
                </div>
            </div>
            
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Traitement en cours...</div>
            </div>
        </div>

        <div class="stats" id="stats" style="display: none;">
            <div class="stat-item">
                <div class="stat-number" id="totalAddresses">0</div>
                <div class="stat-label">Adresses totales</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="successAddresses">0</div>
                <div class="stat-label">Géocodées</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="errorAddresses">0</div>
                <div class="stat-label">Erreurs</div>
            </div>
        </div>

        <div class="main-content" id="mainContent" style="display: none;">
            <div class="map-container">
                <div id="map"></div>
            </div>
            <div class="table-container">
                <div class="table-header">
                    <input type="text" class="search-box" id="searchBox" placeholder="Rechercher une adresse...">
                </div>
                <div class="table-wrapper">
                    <table class="address-table">
                        <thead>
                            <tr>
                                <th>Adresse</th>
                                <th>Ville</th>
                                <th>Code Postal</th>
                                <th>Statut</th>
                            </tr>
                        </thead>
                        <tbody id="addressTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="export-section" id="exportSection" style="display: none;">
            <h3><i class="fas fa-download"></i> Exporter les résultats</h3>
            <p>Téléchargez vos données géocodées dans différents formats :</p>
            <div class="export-buttons">
                <button class="btn" id="exportCsvBtn">
                    <i class="fas fa-file-csv"></i> CSV (Excel)
                </button>
                <button class="btn" id="exportGeoJsonBtn">
                    <i class="fas fa-map-marked"></i> GeoJSON (QGIS)
                </button>
                <button class="btn" id="exportKmlBtn">
                    <i class="fas fa-globe"></i> KML (Google Earth)
                </button>
            </div>
            <div class="export-info">
                <small>
                    <strong>CSV :</strong> Pour Excel, LibreOffice<br>
                    <strong>GeoJSON :</strong> Pour QGIS, ArcGIS, Leaflet<br>
                    <strong>KML :</strong> Pour Google Earth, Google Maps
                </small>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner">
            <div class="spinner"></div>
            <div>Géocodage en cours...</div>
        </div>
    </div>

    <!-- Leaflet JS pour la carte -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    
    <!-- Papa Parse pour lire les CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <script>
        // Variables globales pour stocker les données
        let addressesData = [];
        let csvData = []; // Données brutes du CSV
        let csvHeaders = []; // En-têtes du CSV
        let map = null;
        let markersLayer = null;
        let currentSelectedRow = null;

        // Initialisation quand la page est chargée
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
        });

        // Configuration des écouteurs d'événements
        function setupEventListeners() {
            const fileInput = document.getElementById('fileInput');
            const uploadArea = document.getElementById('uploadArea');
            const searchBox = document.getElementById('searchBox');
            const exportCsvBtn = document.getElementById('exportCsvBtn');
            const exportGeoJsonBtn = document.getElementById('exportGeoJsonBtn');
            const exportKmlBtn = document.getElementById('exportKmlBtn');
            const startGeocodingBtn = document.getElementById('startGeocodingBtn');
            const resetBtn = document.getElementById('resetBtn');

            // Gestion du fichier CSV
            fileInput.addEventListener('change', handleFileSelect);
            
            // Gestion du drag and drop
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleFileDrop);
            uploadArea.addEventListener('click', () => fileInput.click());

            // Recherche dans le tableau
            searchBox.addEventListener('input', filterAddresses);

            // Export des résultats
            exportCsvBtn.addEventListener('click', () => exportResults('csv'));
            exportGeoJsonBtn.addEventListener('click', () => exportResults('geojson'));
            exportKmlBtn.addEventListener('click', () => exportResults('kml'));

            // Boutons de mapping
            startGeocodingBtn.addEventListener('click', startGeocodingWithMapping);
            resetBtn.addEventListener('click', resetUpload);

            // Écouteurs pour la prévisualisation
            ['numeroColumn', 'rueColumn', 'codePostalColumn', 'communeColumn'].forEach(id => {
                document.getElementById(id).addEventListener('change', updatePreview);
            });
        }

        // Gestion du drag and drop
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
        }

        function handleFileDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }

        // Gestion de la sélection de fichier
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        // Traitement du fichier CSV
        function processFile(file) {
            if (!file.name.toLowerCase().endsWith('.csv')) {
                alert('Veuillez sélectionner un fichier CSV.');
                return;
            }

            // Parse le fichier CSV avec Papa Parse
            Papa.parse(file, {
                header: true, // Première ligne = noms des colonnes
                skipEmptyLines: true,
                complete: function(results) {
                    csvData = results.data;
                    csvHeaders = results.meta.fields || Object.keys(csvData[0] || {});
                    
                    console.log('Données CSV chargées:', csvData);
                    console.log('En-têtes détectées:', csvHeaders);
                    
                    if (csvHeaders.length === 0) {
                        alert('Impossible de détecter les colonnes du fichier CSV.');
                        return;
                    }

                    // Vérifier s'il y a une colonne "adresse" directe
                    const addressColumn = csvHeaders.find(header => 
                        header.toLowerCase().includes('adresse') || 
                        header.toLowerCase() === 'adresse'
                    );

                    if (addressColumn && csvData[0][addressColumn]) {
                        // Utilisation directe si une colonne adresse existe
                        const confirmDirect = confirm(
                            `Une colonne "${addressColumn}" a été détectée. Voulez-vous l'utiliser directement ?\n\n` +
                            `Cliquez sur "OK" pour utiliser cette colonne.\n` +
                            `Cliquez sur "Annuler" pour configurer manuellement les colonnes.`
                        );
                        
                        if (confirmDirect) {
                            const directData = csvData.map(row => ({ adresse: row[addressColumn] }));
                            startGeocoding(directData);
                            return;
                        }
                    }

                    // Afficher l'interface de mapping
                    showColumnMapping();
                },
                error: function(error) {
                    console.error('Erreur lors de la lecture du CSV:', error);
                    alert('Erreur lors de la lecture du fichier CSV.');
                }
            });
        }

        // Démarrage du processus de géocodage
        async function startGeocoding(data) {
            addressesData = []; // Réinitialiser les données
            
            // Afficher la barre de progression
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('loadingOverlay').style.display = 'flex';

            const totalAddresses = data.length;
            let processedCount = 0;

            // Traiter chaque adresse
            for (let i = 0; i < data.length; i++) {
                const row = data[i];
                const address = row.adresse;

                if (address && address.trim()) {
                    try {
                        const geocodeResult = await geocodeAddress(address.trim());
                        addressesData.push({
                            originalAddress: address,
                            ...geocodeResult,
                            originalRow: row
                        });
                    } catch (error) {
                        addressesData.push({
                            originalAddress: address,
                            status: 'error',
                            error: error.message,
                            originalRow: row
                        });
                    }
                }

                processedCount++;
                updateProgress(processedCount, totalAddresses);

                // Pause pour éviter de surcharger l'API
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Finaliser le traitement
            document.getElementById('loadingOverlay').style.display = 'none';
            displayResults();
        }

        // Fonction de géocodage utilisant l'API de la Base d'Adresse Nationale
        async function geocodeAddress(address) {
            try {
                const url = `https://api-adresse.data.gouv.fr/search/?q=${encodeURIComponent(address)}&limit=1`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }

                const data = await response.json();

                if (data.features && data.features.length > 0) {
                    const feature = data.features[0];
                    const props = feature.properties;
                    const coords = feature.geometry.coordinates;

                    return {
                        status: 'success',
                        latitude: coords[1],
                        longitude: coords[0],
                        formattedAddress: props.label,
                        city: props.city,
                        postcode: props.postcode,
                        score: props.score
                    };
                } else {
                    return {
                        status: 'not_found',
                        error: 'Adresse non trouvée'
                    };
                }
            } catch (error) {
                return {
                    status: 'error',
                    error: error.message
                };
            }
        }

        // Mise à jour de la barre de progression
        function updateProgress(processed, total) {
            const percentage = (processed / total) * 100;
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = 
                `Traitement: ${processed}/${total} adresses (${Math.round(percentage)}%)`;
        }

        // Affichage des résultats
        function displayResults() {
            // Masquer la section upload et afficher les résultats
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('stats').style.display = 'flex';
            document.getElementById('mainContent').style.display = 'flex';
            document.getElementById('exportSection').style.display = 'block';

            // Calculer les statistiques
            const total = addressesData.length;
            const success = addressesData.filter(addr => addr.status === 'success').length;
            const errors = total - success;

            document.getElementById('totalAddresses').textContent = total;
            document.getElementById('successAddresses').textContent = success;
            document.getElementById('errorAddresses').textContent = errors;

            // Initialiser la carte
            initializeMap();

            // Remplir le tableau
            populateTable();
        }

        // Initialisation de la carte Leaflet
        function initializeMap() {
            // Créer la carte centrée sur la France
            map = L.map('map').setView([46.603354, 1.888334], 6);

            // Ajouter le fond de carte OpenStreetMap
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);

            // Créer un groupe de marqueurs
            markersLayer = L.layerGroup().addTo(map);

            // Ajouter les marqueurs pour les adresses géocodées avec succès
            const successAddresses = addressesData.filter(addr => addr.status === 'success');
            
            if (successAddresses.length > 0) {
                const group = new L.featureGroup();
                
                successAddresses.forEach((addr, index) => {
                    const marker = L.marker([addr.latitude, addr.longitude])
                        .bindPopup(`
                            <strong>${addr.formattedAddress}</strong><br>
                            ${addr.city || ''} ${addr.postcode || ''}<br>
                            <em>Adresse originale:</em> ${addr.originalAddress}
                        `)
                        .on('click', function() {
                            selectAddressInTable(index);
                        });
                    
                    markersLayer.addLayer(marker);
                    group.addLayer(marker);
                });

                // Ajuster la vue pour afficher tous les marqueurs
                map.fitBounds(group.getBounds(), { padding: [20, 20] });
            }
        }

        // Remplissage du tableau
        function populateTable() {
            const tableBody = document.getElementById('addressTableBody');
            tableBody.innerHTML = '';

            addressesData.forEach((addr, index) => {
                const row = document.createElement('tr');
                row.dataset.index = index;
                
                const statusClass = addr.status === 'success' ? 'status-success' : 'status-error';
                const statusText = addr.status === 'success' ? '✓ Trouvée' : '✗ ' + (addr.error || 'Non trouvée');

                row.innerHTML = `
                    <td>${addr.originalAddress}</td>
                    <td>${addr.city || '-'}</td>
                    <td>${addr.postcode || '-'}</td>
                    <td class="${statusClass}">${statusText}</td>
                `;

                row.addEventListener('click', function() {
                    selectAddress(index);
                });

                tableBody.appendChild(row);
            });
        }

        // Sélection d'une adresse dans le tableau
        function selectAddress(index) {
            // Retirer la sélection précédente
            if (currentSelectedRow) {
                currentSelectedRow.classList.remove('selected');
            }

            // Sélectionner la nouvelle ligne
            const row = document.querySelector(`tr[data-index="${index}"]`);
            row.classList.add('selected');
            currentSelectedRow = row;

            const addr = addressesData[index];

            // Si l'adresse a été géocodée avec succès, centrer la carte
            if (addr.status === 'success') {
                map.setView([addr.latitude, addr.longitude], 15);
                
                // Ouvrir le popup du marqueur correspondant
                markersLayer.eachLayer(function(marker) {
                    const pos = marker.getLatLng();
                    if (Math.abs(pos.lat - addr.latitude) < 0.0001 && 
                        Math.abs(pos.lng - addr.longitude) < 0.0001) {
                        marker.openPopup();
                    }
                });
            }
        }

        // Sélection depuis la carte
        function selectAddressInTable(index) {
            selectAddress(index);
            
            // Faire défiler jusqu'à la ligne dans le tableau
            const row = document.querySelector(`tr[data-index="${index}"]`);
            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Filtrage des adresses dans le tableau
        function filterAddresses() {
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();
            const rows = document.querySelectorAll('#addressTableBody tr');

            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                const shouldShow = text.includes(searchTerm);
                row.style.display = shouldShow ? '' : 'none';
            });
        }

        // Export des résultats dans différents formats
        function exportResults(format) {
            const timestamp = new Date().toISOString().split('T')[0]; // Format YYYY-MM-DD
            
            switch(format) {
                case 'csv':
                    exportCSV(timestamp);
                    break;
                case 'geojson':
                    exportGeoJSON(timestamp);
                    break;
                case 'kml':
                    exportKML(timestamp);
                    break;
                default:
                    exportCSV(timestamp);
            }
        }

        // Export au format CSV
        function exportCSV(timestamp) {
            const csvData = addressesData.map(addr => ({
                'Adresse originale': addr.originalAddress,
                'Adresse formatée': addr.formattedAddress || '',
                'Ville': addr.city || '',
                'Code postal': addr.postcode || '',
                'Latitude': addr.latitude || '',
                'Longitude': addr.longitude || '',
                'Statut': addr.status,
                'Score de confiance': addr.score || '',
                'Erreur': addr.error || ''
            }));

            const csv = Papa.unparse(csvData);
            downloadFile(csv, `geocodage_resultats_${timestamp}.csv`, 'text/csv');
        }

        // Export au format GeoJSON (parfait pour QGIS)
        function exportGeoJSON(timestamp) {
            const successAddresses = addressesData.filter(addr => addr.status === 'success');
            
            const geojson = {
                type: "FeatureCollection",
                crs: {
                    type: "name",
                    properties: {
                        name: "EPSG:4326" // Système de coordonnées WGS84
                    }
                },
                features: successAddresses.map((addr, index) => ({
                    type: "Feature",
                    properties: {
                        id: index + 1,
                        adresse_originale: addr.originalAddress,
                        adresse_formatee: addr.formattedAddress || '',
                        ville: addr.city || '',
                        code_postal: addr.postcode || '',
                        score_confiance: addr.score || 0,
                        statut: addr.status
                    },
                    geometry: {
                        type: "Point",
                        coordinates: [addr.longitude, addr.latitude] // GeoJSON utilise [lon, lat]
                    }
                }))
            };

            const geojsonString = JSON.stringify(geojson, null, 2);
            downloadFile(geojsonString, `geocodage_points_${timestamp}.geojson`, 'application/geo+json');
        }

        // Export au format KML (Google Earth, etc.)
        function exportKML(timestamp) {
            const successAddresses = addressesData.filter(addr => addr.status === 'success');
            
            let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Géocodage - Résultats</name>
    <description>Points géocodés avec l'API Base d'Adresse Nationale</description>
    
    <Style id="addressPoint">
      <IconStyle>
        <Icon>
          <href>https://maps.google.com/mapfiles/kml/paddle/red-circle.png</href>
        </Icon>
        <scale>1.0</scale>
      </IconStyle>
      <LabelStyle>
        <color>ff0000ff</color>
        <scale>0.8</scale>
      </LabelStyle>
    </Style>
`;

            successAddresses.forEach((addr, index) => {
                kml += `
    <Placemark>
      <name>${escapeXml(addr.city || 'Adresse ' + (index + 1))}</name>
      <description><![CDATA[
        <b>Adresse originale:</b> ${escapeXml(addr.originalAddress)}<br/>
        <b>Adresse formatée:</b> ${escapeXml(addr.formattedAddress || '')}<br/>
        <b>Ville:</b> ${escapeXml(addr.city || '')}<br/>
        <b>Code postal:</b> ${escapeXml(addr.postcode || '')}<br/>
        <b>Score de confiance:</b> ${addr.score || 0}
      ]]></description>
      <styleUrl>#addressPoint</styleUrl>
      <Point>
        <coordinates>${addr.longitude},${addr.latitude},0</coordinates>
      </Point>
    </Placemark>`;
            });

            kml += `
  </Document>
</kml>`;

            downloadFile(kml, `geocodage_points_${timestamp}.kml`, 'application/vnd.google-earth.kml+xml');
        }

        // Fonction utilitaire pour échapper les caractères XML
        function escapeXml(unsafe) {
            return unsafe.replace(/[<>&'"]/g, function (c) {
                switch (c) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case '\'': return '&apos;';
                    case '"': return '&quot;';
                }
            });
        }

        // Fonction utilitaire pour télécharger un fichier
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType + ';charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            } else {
                // Fallback pour les navigateurs plus anciens
                window.open('data:' + mimeType + ';charset=utf-8,' + encodeURIComponent(content));
            }
        }
    </script>
    <!-- Bouton de retour vers la page des outils -->
<div style="text-align: center; margin: 30px 0; padding: 20px 0; border-top: 1px solid #ddd;">
    <a href="../outils.html" 
       style="display: inline-block; 
              padding: 12px 24px; 
              background-color: #007bff; 
              color: white; 
              text-decoration: none; 
              border-radius: 5px; 
              font-weight: bold;
              transition: background-color 0.3s;">
        ← Retour aux outils
    </a>
</div>
</body>
</html>
